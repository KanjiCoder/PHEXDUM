
//: PHEXDUM.F._ :PNG_HEX_DUMP: Functions

//:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION:=====================://
    void 
    aac2020_phexdum_Halt( const char* msg_err )
    {
        printf("[FATAL_ERROR:aac2020_phexdum]:%s\n", msg_err );
        fflush(stdout);
        exit( 189 );
    }
//:=====================:HALT_IS_TYPICALLY_THE_FIRST_FUNCTION://
//:LOG_AFTER_HALT:===========================================://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 01 ://
#define CHR const char                                //: 02 ://
#define ERR aac2020_phexdum_Halt                      //: 03 ://

    void
    aac2020_phexdum_Info_any(
        CHR*  str_fmt
    ,   void* dat_any   
    )
    { 

        I32 logging_is_on=( 0 - 1234 /**INVALID_VALUE**/ );
        
        #ifdef AAC2020_INCLUDE_SILENCE
        /** Compiled as part of main AAC2020 engine. **/
            
            if( AAC2020_SILENCE.PHEXDUM <= 0 ){
                logging_is_on=( 1 );
            }else
            if( AAC2020_SILENCE.PHEXDUM >= 1 ){
                logging_is_on=( 0 );
            }else{
                ERR("[WTF_ARE_YOU_DOING?]");
            };;

        #else
        /** Compiled as stand-alone command line utility. **/

            logging_is_on =( 
                AAC2020_PHEXDUM_STAND_ALONE_ONLY_LOGGING_ON );;

        #endif

        //: 
        if( logging_is_on >= 1 ){
            /** Same Line As Next Printf **/
            printf("[phexdum_log]....(   " ); fflush( stdout );
            printf( str_fmt , dat_any      ); fflush( stdout );
            printf(               "   )\n" ); fflush( stdout );
        }else
        if( 0 == logging_is_on ){
            /** do nothing **/
        }else{
            ERR("[YOUR_LOGGING_CONFIG_LOGIC_SUCKS_2021]");
        };;
        
    }

#undef  I32  //:----------------------------------------: 01 ://
#undef  CHR  //:----------------------------------------: 02 ://
#undef  ERR  //:----------------------------------------: 03 ://
//:===========================================:LOG_AFTER_HALT://
//:INFO_PRINT_STRING:========================================://
#define CHR const char
#define ERR aac2020_phexdum_Halt

    /** ****************************************** **/
    /** I'd like to get rid of this function. But  **/
    /** right now just get things working.         **/
    /** @VID_IID[ 0121 ]TIME[ 01:12:55 ] ********* **/
    /** ****************************************** **/

    void
    aac2020_phexdum_Info_str( 
        CHR* msg_fmt /** Format String **/
    ,   CHR* msg_inf /** Information String **/
    )
    {
        if( ((CHR*)0) == msg_fmt ){ ERR("[NIL:msg_fmt]"); };
        if( ((CHR*)0) == msg_inf ){ ERR("[NIL:msg_inf]"); };
        
        aac2020_phexdum_Info_any(
                   msg_fmt
        ,   (void*)msg_inf
        );;
    }

#undef  CHR
#undef  ERR
//:========================================:INFO_PRINT_STRING://
//:==========================================================://
//:FILE_READ_WRITE_SECTION:||||||||||||||||||||||||||||||||||://
//:==========================================================://
#define I_S aac2020_phexdum_Info_str

    //:PRIVATE:RECURIVE_MAKE_DIRECTORY:======================://

        int
        aac2020_phexdum_MakeOneDirectory(
            const char* name
        )
        {
            int mkdir_status_zero_is_success=( 23 );

            #ifdef __linux__
                mkdir_status_zero_is_success =  mkdir(name, 0777);  
            #else
                mkdir_status_zero_is_success =  mkdir(name);
            #endif

            return( mkdir_status_zero_is_success );
        }

        //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://

        void aac2020_phexdum_mkdir(char* path) 
        {
            if( ((char*)0) != strrchr(path, '\\' ) ){
                aac2020_phexdum_Halt("BACK_SLASHES_NOT_SUPPORTED]");
            };;

            char *sep = strrchr(path, '/');
            if( ((char*)0) != sep ){

                *sep = 0;
                aac2020_phexdum_mkdir(path);
                *sep = '/';
            };;

            if(
                aac2020_phexdum_MakeOneDirectory(path) 
            && 
                errno != EEXIST
            ){
                //: if( AAC2020_SILENCE.PHEXDUM <= 0 ){

                    /** REVISIT[ DATE[ 2020_12_09 ] ] ********** **/
                    /** Is this an error? Why the fuck did I     **/
                    /** Write this? I have no clue what this     **/
                    /** should mean? Is it info or actually      **/
                    /** an error that should fail fast?          **/
                    I_S("[FUCKING_FILES_MAN]:(((%s)))\n", path); 

                //: };;
            };;
        }

    //:======================:PRIVATE:RECURIVE_MAKE_DIRECTORY://
    //:TOUCH_FILE:===========================================://
    #define U32 uint32_t /** GCC: <stdint.h> **/
    #define SMF aac2020_phexdum_Halt /** SMF:SupriseMotherFucker **/
    #define MACRO_MAX_LEN ( 256 )
    #define LOG aac2020_phexdum_Info_any
    #define ERR aac2020_phexdum_Halt
    #define CHR const char

        U32
        AAC2020_PHEXDUM_TouchFile(
            const char* fil_nam /** EX:fip_inn **/
        )
        {
            LOG("[AAC2020_PHEXDUM_TouchFile:BEG]",0);
            if( ((CHR*)0) == fil_nam ){
                ERR("[AAC2020_PHEXDUM_TouchFile:NIL_FILE]");
            };;
            I_S("[PHEXDUM_TouchFile]:%s\n" , fil_nam );;  

            //:GET_STR_LEN_AND_VALIDATE:---------------------://
            #define NILIDEX ( 1 ) /** 1 null terminator **/

                int str_len = strlen( fil_nam );
                if( str_len > ( MACRO_MAX_LEN - NILIDEX ) ){

                    /** Must be short enough to accomidate     **/
                    /** Length of string plus null terminator. **/
                    aac2020_phexdum_Halt("[TOO_LONG]");

                };;
            
            #undef  NILIDEX  /** 1 null terminator **/
            //:---------------------:GET_STR_LEN_AND_VALIDATE://
            //:EXPECT_EXACTLY_ONE_DOT:-----------------------://
            //:DO_NOT_ALLOW_BACKSLASH:-----------------------://

                /** These constraints will make it easier to     **/
                /** implement your code. * * * * * * * * * * * * **/

                int nos = ( 0 ); /** nos: Number_Of_back_Slashes **/
                int nod = ( 0 ); /** nod: Number_Of_Dots **/
                for( int i = 0; i < str_len; i++ ){

                    if( fil_nam[i] == '.'  ){ nod++; };
                    if( fil_nam[i] == '\\' ){ nos++; };

                };;

                if( nod >   1  ){ SMF("[TOO_MANY_DOTS]"); }else
                if( nod <=  0  ){ SMF("[ZERO_____DOTS]"); }else
                if(  1  == nod ){ /** OKAY. NOOP **/    }else
                {
                    SMF("[WTF:EDCL]");//:ExpectedDeadCodeLine
                };; 

                if( nos != 0 ){ SMF("[UNDOCUMENTED_BACKSLASHES]");};

            //:-----------------------:DO_NOT_ALLOW_BACKSLASH://
            //:-----------------------:EXPECT_EXACTLY_ONE_DOT://
            //:CREATE_DIRECTORY:-----------------------------://

                //:PATH_ONLY_SUB_STRING:- - - - - - - - - - - - -://

                    //:FIND__LAST_SLASH:. . . . . . . . . . . . .://

                        int dex_last_slash =( 0 - 1 );
                        for( int i = 0; i < str_len; i++ ){
                            if( '/' == fil_nam[ i ]  ){
                                dex_last_slash =( i );
                            };;
                        };;

                    //:. . . . . . . . . . . . .:FIND__LAST_SLASH://
                    //:TAKE_TO_LAST_SLASH:. . . . . . . . . . . .://

                        /** dir_sus : DIRectory_SUb_String **/
                        char dir_sus[ MACRO_MAX_LEN ] = {0};
                        for( int i = 0; i < dex_last_slash; i++ ){

                            if( '.' != fil_nam[ i ]  ){

                                dir_sus[ i ] = fil_nam[ i ];

                            }else{
                                //:DNE:Did_Not_Expect
                                //:DBL:Dot_Before_Lastslash
                                aac2020_phexdum_Halt("[DNE_DBL]");
                            };;

                        };;

                    //:. . . . . . . . . . . .:TAKE_TO_LAST_SLASH://

                //:- - - - - - - - - - - - -:PATH_ONLY_SUB_STRING://
                //:RECURSIVE_MAKE_DIR:- - - - - - - - - - - - - -://
     
                    if( dex_last_slash <= 0 ){
                            
                        /** Creation of directory requires at  * **/
                        /** least ONE character BEFORE the     * **/
                        /** last slash.                        * **/
                        /** Example/Reason: f/t.x              * **/

                    }else
                    if( dex_last_slash  < 1 ){

                        /** ECATOH: ExpectedCaseAboveTOHandle  * **/
                        /** "<1" is the same as "<=0"          * **/
                        aac2020_phexdum_Halt("[ECATOH]");

                    }else{

                        //:RECURSIVE_MAKE_DIR:4REAL:. . . . . . .://

                            I_S("[MAKING_DIRECTORY:dir_sus]:%s\n"
                                                  ,dir_sus);;

                            /** dir_sus : DIRectory_SUb_String **/
                            aac2020_phexdum_mkdir( dir_sus );

                        //:. . . . . . .:RECURSIVE_MAKE_DIR:4REAL://

                    };;

                //:- - - - - - - - - - - - - -:RECURSIVE_MAKE_DIR://

            //:---------------------------------:CREATE_DIRECTORY://
            //:CREATE_FILE_IF_NOT_EXIST:-------------------------://

                /** Open For: APPEND/BINARY/UPDATE (a/b/+)   * * **/
                /** Using wrong open can DELETE FILE CONTENTS  * **/
                /** Which is not what we want. We want a touch.  **/
                FILE*   fil_han = fopen( fil_nam , "ab+" );
                fclose( fil_han );

            //:-------------------------:CREATE_FILE_IF_NOT_EXIST://

            LOG("[AAC2020_PHEXDUM_TouchFile:END]",0);
            return( 0x00 );
        }

    #undef  MACRO_MAX_LEN
    #undef  SMF /** www.youtube.com/watch?v=_bSEfx6D8mA **/
    #undef  U32
    #undef  LOG
    #undef  ERR
    #undef  CHR
    //:===========================================:TOUCH_FILE://
    //:SAVE_TXT_FILE_TO_DISK:================================://
    //:SAVE_C99_FILE_TO_DISK:================================://
    #define I32  int32_t /** GCC: <stdint.h> **/      //: 01 ://
    #define U32 uint32_t /** GCC: <stdint.h> **/      //: 02 ://
    #define CHR const char                            //: 03 ://
    #define LOG aac2020_phexdum_Info_any              //: 04 ://
    #define ERR aac2020_phexdum_Halt                  //: 05 ://

        I32
        AAC2020_PHEXDUM_SaveFile_TXT(
            CHR* nof_wex /** NameOfFile__WithEXtension   ....**/
        ,   CHR* chr_arr /** String To Save To Disk .........**/
        ,   U32  str_len /** Num Chars In chr_arr   .........**/
        )
        {
        /** ************************************************ ***
        @VID_IID[ 0120 ]TIME[ 07:44:05 ]
        Decided on[ AAC2020_PHEXDUM_SaveFile_TXT ]
        Instead of[ AAC2020_PHEXDUM_SaveFile_TEX ]
        Because "TEX" can mean "Texture" in some contexts.
        *** ************************************************ **/
            LOG("[AAC2020_PHEXDUM_SaveFile_TXT:BEG]",0);
            //:input_checks:---------------------------------://
            #define N_S ((CHR*)0)

                /** @VID_IID[ 0121 ]TIME[ 00:31:00 ] **/
                /** ZON: Zero_Or_Negative.           **/
                if( N_S == nof_wex ){ ERR("[NIL:nof_wex]"); };
                if( N_S == chr_arr ){ ERR("[NIL:chr_arr]"); };
                if(  0  >= str_len ){ ERR("[ZON:str_len]"); };

            #undef  N_S
            //:---------------------------------:input_checks://
            //:declare_variables:----------------------------://

                FILE* fil_han =((FILE*)0 );
                I32   fil_nob =( 0 - 747 );

            //:----------------------------:declare_variables://

            /** EXAMPLE:    TouchFile( "myTextFile.txt" );   **/
            AAC2020_PHEXDUM_TouchFile( nof_wex );

            /** ******************************************** ***
            @VID_IID[ 0120 ]TIME[ 09:16:20 ] ( "w+" )
            @VID_IID[ 0120 ]TIME[ 09:33:12 ] ( "w"  )
            @VID_IID[ 0121 ]TIME[ 00:37:42 ] ( rbsrbs says )
            https://linux.die.net/man/3/fdopen

                rbsrbs: that will always be 0 
                        if you open in mode "w"

                rbsrbs: in linux b is ignored but 
                        always good to be explicit
            *** ******************************************** **/

            /** Create if not exist. Truncate to zero. **/
            fil_han = fopen( nof_wex , "wb" );

            //:get_number_of_bytes_in_file:------------------://
            /** SEEK_SET : GCC: unistd.h && mmsystem.h **/
            /** SEEK_END : GCC: unistd.h && mmsystem.h **/
            #define MACRO_SEEK_SET 0  
            #define MACRO_SEEK_END 2  

                //:Seek to end and get number of bytes.
                //:Then reset file handle to start of file.
                fseek( fil_han , 0 , MACRO_SEEK_END );
                fil_nob = ftell( fil_han ); 
                fseek( fil_han , 0 , MACRO_SEEK_SET );

            #undef  MACRO_SEEK_SET
            #undef  MACRO_SEEK_END
            //:------------------:get_number_of_bytes_in_file://
            //:make_sure_number_of_bytes_is_zero:------------://

                if( 0  > fil_nob ){

                    printf("[fil_nob]:%d\n" , fil_nob );
                    ERR("[NEGATIVE_NUMBER_OF_BYTES_IN_FILE]");

                }else
                if( 0 != fil_nob ){

                    printf("[fil_nob]:%d\n" , fil_nob );
                    ERR("[EXPECTED_TRUNCATED_TO_ZERO_FILE]");

                };;

            //:------------:make_sure_number_of_bytes_is_zero://
            //:write_text_using_binary_write:----------------://
            #define MACRO_SEEK_SET 0  /**unistd.h, mmsystem.h**/

                if( ((void*)0) != fil_han ){
                
                    fseek( fil_han , 0 , MACRO_SEEK_SET );
                    fwrite( 
                        chr_arr
                    ,   1       //:[ ASCII_CHAR == 1 byte ]://  
                    ,   str_len //:Number_Of_Characters
                                //:NOT[ str_nob ]because strings  
                                //:not null term in text files .
                
                    ,   fil_han //:File We are writing into.
                    );;
                    fclose( fil_han );
                
                }else{
                    /** IDKWID: I_Dont_Know_What_Iam_Doing **/
                    printf("[SAVE_FAIL:nof_wex]:%s\n",nof_wex);
                    ERR("[FAIL_TO_SAVE_TEXT_FILE:WHY:IDKWID]");
                };;

            #undef  MACRO_SEEK_SET
            //:----------------:write_text_using_binary_write://

            LOG("[AAC2020_PHEXDUM_SaveFile_TXT:END]",0);
            return( 0x00 );
        }
            
    #undef  I32  //:------------------------------------: 01 ://
    #undef  U32  //:------------------------------------: 02 ://
    #undef  CHR  //:------------------------------------: 03 ://
    #undef  LOG  //:------------------------------------: 04 ://
    #undef  ERR  //:------------------------------------: 05 ://
    //:================================:SAVE_C99_FILE_TO_DISK://
    //:================================:SAVE_TXT_FILE_TO_DISK://
    //:SAVE_PNG_FILE_TO_DISK:================================://
    #define U08    uint8_t /** GCC: <stdint.h> **/    //: 01 ://
    #define U32   uint32_t /** GCC: <stdint.h> **/    //: 02 ://
    #define I32    int32_t /** GCC: <stdint.h> **/    //: 03 ://
    #define CHR const char                            //: 04 ://
    #define TXT       char                            //: 05 ://
    #define ERR aac2020_phexdum_Halt                  //: 06 ://

        int
        AAC2020_PHEXDUM_SaveFile_PNG(
            CHR* nof_wex /** NameOfFile__WithEXtension       ....**/
        ,   U08* pix_arr /** PIXel ARRay in RGBA byte format ....**/
        ,   U32  pix_wid /** Width  in pixels of pix_arr     ....**/
        ,   U32  pix_hig /** Height in pixels of pix_arr     ....**/
        )
        {
            /** @VID_IID[ 0095 ]TIME[ 01:32:50 ] *************** **/
            /** This function was made by copying and pasting    **/
            /** R:\G\AAC2020\LIB\MAIN\AAC2020_TestSaveFile_PNG._ **/
            /** and refactoring it to be more general use.       **/
            /** ************************************************ **/

            //:error_check_inputs:-------------------------------://

                if( ((CHR*)0) == nof_wex ){ 
                    ERR("[KANJICODER_SAYS:NIL_STR_nof_wex_2021]");
                };;

                if( ((U08*)0) == pix_arr ){ 
                    ERR("[KANJICODER_SAYS:NIL_ARR_pix_arr:2021]");
                };;
                if( 0 == pix_wid || 0 == pix_hig ){
                    ERR("[INVALID_PNG_SIZE]");
                };;

                /** ".PNG" is 4 characters. Thus file name **/
                /** should be MORE than 4 characters.      **/
                if( strlen( nof_wex ) <= 4 ){
                    ERR("[NO_POSSIBLE_WAY_NAME_IS_VALID_2021]");
                };;

                if(   '/' == nof_wex[ 0 ] //:FORWARDSLASH___CHAR
                ||   '\\' == nof_wex[ 0 ] //:BACKSLASH_CHARACTER
                ){
                    ERR("[DO_NOT_PUT_SLASH_BEFORE_BASE_FOLDER]");
                };;

            //:-------------------------------:error_check_inputs://

            //- unsigned char pix_arr[512*512*4]; //:AKA[ image ]-//
            //- unsigned int  pix_wid=( 512 );                   -//
            //- unsigned int  pix_hig=( 512 );                   -//

            //:SAVE_FILE_PNG:------------------------------------://
            #define FILE_PNG ( "USE:nof_wex" );

                //:create_relative_file_path:fil_png:------------://

                    /**  @VID_IID[ 0095 ]TIME[ 01:08:42 ] ...... **/
                    /**  Base Name Of The Saved File.     ...... **/
                    CHR* nam_bas = "MOD/" ;

                    I32  len_nof = strlen( nof_wex );
                    I32  len_bas = strlen( nam_bas );
                    I32  len_all =( len_nof + len_bas );
                    TXT* fil_png =((TXT*)0);

                    /** @VID_IID[ 0095 ]TIME[ 01:07:20 ]  ...... **/
                    /** Create max index (m_i) variables. ...... **/
                    I32 m_i_bas =( len_bas           - 1 );
                    I32 m_i_nof =( len_nof + len_bas - 1 );

                    fil_png = calloc(1, ( len_all + 1 ) );

                    I32 l_i =( 0 ); //:local_index

                    for( I32 i = 0 ; i < len_all ; i ++ ){

                        if( i >=(   0   )
                        &&  i <=(m_i_bas)
                        ){
                            l_i =( i - 0 );
                            if( l_i < 0 || l_i > m_i_bas ){
                                ERR("[l_i:OOB:FROM:BASEFOLDER]");
                            };;

                            fil_png[ i ] = nam_bas[ l_i ];
                        }else
                        if( i >=( m_i_bas + 1 ) 
                        &&  i <=( m_i_nof + 0 )
                        ){
                            /** @VID_IID[ 0096 ]TIME[ 00:13:00 ] **/
                            /** Minus_One_Fix_To_Var[ l_i ]  *** **/
                            l_i =( i - m_i_bas - 1 );
                            if( l_i < 0 || l_i > (len_nof-1) ){
                                ERR("[l_i:OOB:FROM:FILENAME]");
                            };;
                            fil_png[ i ] = nof_wex[ l_i ];
                        }else{
                            ERR("[OUT_OF_BOUNDS_SAVE_FILE_2021]");
                        };;
                    };;

                    /** @VID_IID[ 0095 ]TIME[ 01:25:16 ]      ...**/
                    /** Make absolutely sure there is a null  ...**/
                    /** terminator at the end of all of this. ...**/
                    fil_png[ (len_all+1)-1 ]=( 0x00 );

                //:------------:create_relative_file_path:fil_png://

                //: We don't have a touchFolder, only TouchFile.
                //: AAC2020_PHEXDUM_TouchFolder("./MOD");
                AAC2020_PHEXDUM_TouchFile( fil_png /**file_png**/ );

                U32 result = ( 11223344 /** TRAPVALUE **/ );

                #if( AAC2020_INCLUDE_LODEPNG >= 1 ) //:##########://

                    result=( 
                        lodepng_encode32_file( 

                            fil_png  //:AKA[ file_png ]

                        ,   pix_arr  //:AKA[ image ]
                        ,   pix_wid 
                        ,   pix_hig
                        )
                    );;

                #endif //:#######################################://
                #if( AAC2020_INCLUDE_LODEPNG <= 0 ) //:##########://

                    /** @VID_IID[ 3H 17M 18S ] ***************** **/
                    /** When lodepng is not included, we just    **/
                    /** want to pretend it returned success      **/
                    /** so that we do not crash the program.     **/
                    /** ((( result = ( 0 ) )))                   **/
                    /** **************************************** **/

                    result = ( 0 );

                    /** @VID_IID[ 0065 ]TIME[ 3H 19M 29S ]   * * **/
                    /** SILENCE THE COMPILER.                * * **/
                    if( pix_arr[0]> 1 ){ /** NOOP: NO:LODEPNG **/ };
                    if( pix_wid   > 1 ){ /** NOOP: NO:LODEPNG **/ };
                    if( pix_hig   > 1 ){ /** NOOP: NO:LODEPNG **/ };

                    printf("\n\n");
                    printf("[*********************************]\n");
                    printf("[- - - - - - - - - - - - - - - - -]\n");
                    printf("[FROM:LIB/PHEXDUM.F._.............]\n");
                    printf("[- - - - - - - - - - - - - - - - -]\n");
                    printf("[PNG_FILE_IS_JUST_A_STUB_FILE.....]\n");
                    printf("[PLEASE_INCLUDE_LODEPNG_TO_FIX....]\n");
                    printf("[SET:AAC2020_INCLUDE_LODEPNG >= 1 ]\n");
                    printf("[*********************************]\n");
                    printf("[SHOULD_BE_IN: LIBCHAN.TOP._ .....]\n");
                    printf("[*********************************]\n");
                    printf("\n\n");
                    fflush( stdout );

                #endif //:#######################################://
                //:free_calloc_memory:---------------------------://

                    free( fil_png /**[ file_png / file_path ]**/ );

                //:---------------------------:free_calloc_memory://
            #undef  FILE_PNG
            //:------------------------------------:SAVE_FILE_PNG://

            return( result );
        } 

    #undef  U08                                       //: 01 ://
    #undef  U32                                       //: 02 ://
    #undef  I32                                       //: 03 ://
    #undef  CHR                                       //: 04 ://
    #undef  TXT                                       //: 05 ://
    #undef  ERR                                       //: 06 ://
    //:================================:SAVE_PNG_FILE_TO_DISK://
    //:LOAD_FILE_IF_EXISTS:==================================://
    #define I32   int32_t /** GCC: <stdint.h> **/     //: 01 ://
    #define U32  uint32_t /** GCC: <stdint.h> **/     //: 02 ://
    #define U08   uint8_t /** GCC: <stdint.h> **/     //: 03 ://
    #define CHR  const char                           //: 04 ://
    #define LOG  aac2020_phexdum_Info_any             //: 05 ://
    #define ERR  aac2020_phexdum_Halt                 //: 06 ://

        /** @VID_IID[ 01:46:50 ] *************************** **/
        /** Using for both loading of ascii text and         **/
        /** .PNG file binary data.                           **/
        /**                                                  **/
        /** rbsrbs: I don't like that mixing                 **/
        /**                                                  **/
        /** ************************************************ **/
        /** @VID_IID[ 02:04:50 ]                             **/
        /** rbsrbs: last bit of char is implemented defined  **/
        /** ( Because ascii is 7 bits? )                     **/
        /** ************************************************ **/

        U32 
        AAC2020_PHEXDUM_LoadFileIfExists(
            CHR*         fip_inn //:EX:FRAGBED_001.frag
        ,   I32          bin_txt //: 1 == binary is ascii text
        ,   U08*  *BYREF_fil_mem //:DESTINATION
        ,   I32   *BYREF_fil_nob //:Number_Of_Bytes_In:fil_mem
        )
        {
            //:check_inputs:---------------------------------://

                /** References Can Never Be Null **/

                if( ((void*)0) ==  BYREF_fil_mem   ){
                    ERR("[AAC2020_PHEXDUM:REFS_NEVER_NULL]");
                };;

                /** @VID_IID[ 0121 ]TIME[ 01:38:30 ] *** **/
                /** Expect void because this function    **/
                /** has the job of allocating memory and **/
                /** setting the data pointer.            **/
                /** ************************************ **/

                if( ((void*)0) != (*BYREF_fil_mem) ){
                    ERR("[EXPECTED_NULL]");
                };;

            //:---------------------------------:check_inputs://
            //:declare_variables:----------------------------://

                U08* fil_mem     =((void*)0 );
                int  fil_nob     =( 0 - 808 ); //: TrapValue
                int  file_exists =( 0       ); //: 0 ==undefined 

            //:----------------------------:declare_variables://
            //:DOES_THE_FILE_EXIST_ON_DISK:?:----------------://
            #define F_OK 0 /** unistd.h **/
            #define FNAM fip_inn

            if( access( FNAM , 0x00 /** F_OK **/ ) != -1 ) {
            file_exists=( 1 );

            //:DOES_THE_FILE_EXIST_ON_DISK:YES:
     
                //:READ_ALLOCATE_AND_COPY:-------------------://
                /** SEEK_SET : GCC: unistd.h && mmsystem.h **/
                /** SEEK_END : GCC: unistd.h && mmsystem.h **/
                #define MACRO_SEEK_SET 0  
                #define MACRO_SEEK_END 2  

                    //:fil_nob:GET_FILE_NUMBER_OF_BYTES:-----://

                        //:Open file for "read as binary" ("rb")
                              fil_nob =( 0 - 404 );
                        FILE* fil_han = fopen( 
                            fip_inn , "rb" );;
                        
                        //:Seek to end and get number of bytes.
                        //:Reset file handle to start of file.
                        fseek( fil_han , 0 , MACRO_SEEK_END );
                        fil_nob = ftell( fil_han );
                        fseek( fil_han , 0 , MACRO_SEEK_SET );

                    //:fil_nob:GET_FILE_NUMBER_OF_BYTES:-----://
                    //:ALLOCATE_MEMORY:----------------------://

                        if( bin_txt >= 1 ){  /** __IS__ text **/

                            //:1. Allocate_Memory.
                            //:2. Add extra null byte to end.
                            fil_mem = calloc( 1 , fil_nob+1 );
                            ((char*)fil_mem)[ fil_nob ]='\0';
                        }else
                        if( bin_txt <=(0 -1) ){ /** NOT_TEXT **/

                            fil_mem = calloc( 1 , fil_nob+0 );
                        }else{
                            ERR("[bin_txt:zero==undefined]");
                        };;

                        //:Set output parameter(s):
                        (*BYREF_fil_mem)=fil_mem;
                        (*BYREF_fil_nob)=fil_nob;

                    //:----------------------:ALLOCATE_MEMORY://
                    //:READ_FILE_INTO_ALLOCATED_MEMORY:------://

                        fread( 
                            fil_mem  //:<-- DESTINTION(WRITE)
                        ,   fil_nob 
                        ,   1        //:Read 1 byte at a time
                        ,   fil_han  //:SOURCE(READ)
                        );;

                    //:------:READ_FILE_INTO_ALLOCATED_MEMORY://
                    //:DONT_FORGET_TO_CLOSE_FILE:------------://

                        fclose( fil_han );

                    //:------------:DONT_FORGET_TO_CLOSE_FILE://
                #undef MACRO_SEEK_SET
                #undef MACRO_SEEK_END
                //:-------------------:READ_ALLOCATE_AND_COPY://
               
                LOG("[file_YES_on_disk]:%s\n" 
                ,   (void*)((CHR*)fip_inn)
                );;
             
                file_exists=( 0 + 4 );
            }else{ 
                file_exists=( 0 - 4 );
    
                /** **************************************** **/
                /** Not necessary because these would    *** **/
                /** be the original inputs anyways. But  *** **/
                /** do this for clarity and in case      *** **/
                /** code above changes. Set to null      *** **/
                /** and zero to signal failuire.         *** **/
                /** @VID_IID[ 0121 ]TIME[ 04:51:12 ]     *** **/
                /** **************************************** **/

                (*BYREF_fil_mem)=((U08*)0);
                (*BYREF_fil_nob)=(   0   );
       
                LOG("[file_NOT_on_disk]:%s\n"
                , (void*)((CHR*)fip_inn) );;
              
            };;
            #undef  F_OK
            #undef  FNAM
            //:----------------:DOES_THE_FILE_EXIST_ON_DISK:?://
            //:ASSERT_NULL_TERMINATOR:-----------------------://
            #define BYREF_BOI BYREF_fil_mem

                /** ADDED[ DATE[ 2020_11_16 ] ] ************ **/

                if( file_exists >= 1 ){

                    if( '\0' != fil_mem[ fil_nob ] ){
                        ERR("[DONE_FUCKED_UP:001]");
                    };;

                    if( '\0' != (*BYREF_BOI)[ fil_nob ] ){
                        ERR("[DONE_FUCKED_UP:002]");
                    };;

                }else{
                        
                /// Pretty sure this is nonsense left over
                /// from the code we cut+pasted and
                /// refactored.
                ///////////    /** nod_noc: NotOnDisk:NumberOfCharacters **/
                ///////////    int nod_noc = strlen(*BYREF_BOI);
                ///////////
                ///////////    /** nod_nob: NotOnDisk:NumberOfBytes **/ 
                ///////////    int nod_nob = ( nod_noc + 1 );
                ///////////
                ///////////    if( '\0' != (    *BYREF_BOI)[ nod_nob - 1 ]){
                ///////////
                ///////////        ERR("[DONE_FUCKED_UP:003]");
                ///////////
                ///////////    };;

                };;

            #undef BYREF_BOI
            //:-----------------------:ASSERT_NULL_TERMINATOR://

            return( 0x00 );
        }
       
    #undef  I32  //:------------------------------------: 01 ://
    #undef  U32  //:------------------------------------: 02 ://
    #undef  U08  //:------------------------------------: 03 ://
    #undef  CHR  //:------------------------------------: 04 ://
    #undef  LOG  //:------------------------------------: 05 ://
    #undef  ERR  //:------------------------------------: 06 ://
    //:==================================:LOAD_FILE_IF_EXISTS://

#undef  I_S /** aac2020_phexdum_Info_str **/
//:==========================================================://
//:||||||||||||||||||||||||||||||||||:FILE_READ_WRITE_SECTION://
//:==========================================================://
//:PRIVATE_API_HELPER_FUNCTIONS:=============================://
#define I32    int32_t /** GCC: <stdint.h> **/        //: 01 ://
#define U08    uint8_t /** GCC: <stdint.h> **/        //: 02 ://
#define CHR       char /** NON CONST STRING**/        //: 03 ://
#define C_C const char                                //: 04 ://
#define ERR aac2020_phexdum_Halt                      //: 05 ://
#define T_U toupper                                   //: 06 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    I32
    aac2020_phexdum_StrCmp(
        C_C* s_1
    ,   C_C* s_2
    )
    {
    #define CUC const unsigned char

        while( *s_1 && (  T_U(*s_1) == T_U(*s_2)  ) ){
            s_1++;
            s_2++;
        };;

        /** ************************************************ **/
        /** @VID_IID[ 0122 ]TIME[ 00:49:47 ]             *** **/
        /** rbsrbs: the unsigned cast is quite           *** **/
        /**         pedantic indeed                      *** **/
        /** rbsrbs: it's mostly because the last bit of  *** **/
        /**         char being undeterminate again       *** **/
        /** ************************************************ **/
        CUC u_1 = (CUC)( toupper( *s_1 ) ) ;
        CUC u_2 = (CUC)( toupper( *s_2 ) ) ;
        return(  u_1 - u_2  )              ;

    #undef  CUC
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    CHR*
    aac2020_phexdum_CreateFreeableString(
        CHR* non_freeable_string
    )
    {

        I32  str_len =( strlen( non_freeable_string ) );
        CHR* str_out = calloc( str_len + 1 , sizeof( CHR ) );
        str_out[ str_len + 0 ]=( '\0' );
        return( str_out );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    void
    aac2020_phexdum_MAK_hex_str( 
        U08* u08_arr //:INN: array of bytes
    ,   I32  arr_dex //:INN: first index to read

    ,   I32  *BYREF_las_dex  //:OUTPARAM: last_used_index
    ,   CHR*    OUT_hex_str  //:OUTPARAM: built_hex_literal
    )
    {
        //:input_checks:-------------------------------------://

            if( ((U08*)0) == u08_arr ){ ERR("[NIL:u08_arr]"); };

        //:-------------------------------------:input_checks://
        //:core_logic_of_function:---------------------------://
        #define HEX OUT_hex_str   //:-------------------: 01 ://

        /** @VID_IID[ 0121 ]TIME[ 05:52:32 ] **/
        /** rbsrbs: X for hex in cap letters **/
        /** Creates[   "FF" ]                **/
        /**     NOT[ "0xFF" ]                **/

        sprintf( &( HEX[ 0 ]) , "%s"  , "0x"                  );
        sprintf( &( HEX[ 2 ]) , "%02X", u08_arr[ arr_dex + 0 ]);
        sprintf( &( HEX[ 4 ]) , "%02X", u08_arr[ arr_dex + 1 ]);
        sprintf( &( HEX[ 6 ]) , "%02X", u08_arr[ arr_dex + 2 ]);
        sprintf( &( HEX[ 8 ]) , "%02X", u08_arr[ arr_dex + 3 ]);

        #undef  HEX  //:--------------------------------: 01 ://
        //:---------------------------:core_logic_of_function://
        //:said_in_a_clunkier_way:---------------------------://
        /** ************************************************ ***

            The non-compact way to do the above code.
            @VID_IID[ 0121 ]TIME[ 06:02:32 ]INITIAL_CODE
            @VID_IID[ 0121 ]TIME[ 06:08:11 ]FIXED_CODE_BELOW

            //: "FF" + null terminator == 3 characters.  
            CHR b_1[ 3 ]={ 0 };
            CHR b_2[ 3 ]={ 0 };
            CHR b_3[ 3 ]={ 0 };
            CHR b_4[ 3 ]={ 0 };

            OUT_hex_str[ 0 ] = '0' ;
            OUT_hex_str[ 1 ] = 'x' ;
           
            OUT_hex_str[ 2 ] = b_1[ 0 ];
            OUT_hex_str[ 3 ] = b_1[ 1 ];

            OUT_hex_str[ 4 ] = b_2[ 0 ];
            OUT_hex_str[ 5 ] = b_2[ 1 ];

            OUT_hex_str[ 6 ] = b_3[ 0 ];
            OUT_hex_str[ 7 ] = b_3[ 1 ];

            OUT_hex_str[ 8 ] = b_4[ 0 ];
            OUT_hex_str[ 9 ] = b_4[ 1 ];

        *** ************************************************ **/
        //:---------------------------:said_in_a_clunkier_way://
        //:return_output_param(s):---------------------------://

            //: [ 0 ] <-- first index ( arr_dex )
            //: [ 1 ] 
            //: [ 2 ] 
            //: [ 3 ] <-- last  index ( BYREF_las_dex )
            (*BYREF_las_dex)=( arr_dex + (4-1) );

        //:---------------------------:return_output_param(s)://
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32  //:----------------------------------------: 01 ://
#undef  U08  //:----------------------------------------: 02 ://
#undef  CHR  //:----------------------------------------: 03 ://
#undef  C_C  //:----------------------------------------: 04 ://
#undef  ERR  //:----------------------------------------: 05 ://
#undef  T_U  //:----------------------------------------: 06 ://
//:=============================:PRIVATE_API_HELPER_FUNCTIONS://
//:PUBLIC_PROGRAM_API_FUNCTIONS:=============================://
#define U08 uint8_t /** GCC: <stdint.h> **/           //: 01 ://
#define I32 int32_t /** GCC: <stdint.h> **/           //: 02 ://
#define CHR char                                      //: 03 ://
#define ERR aac2020_phexdum_Halt                      //: 04 ://

    void
    AAC2020_PHEXDUM_u08_arr_CTO_nak_tex(

        U08*        u08_arr /**BINARY BYTES -or- PIXELS .....**/
    ,   I32         arr_len /**rbsrbs: u08_pix_size .........**/

    ,   CHR*             *BYREF_nak_tex
    ,   I32              *BYREF_nak_len

    )
    {
    #define HEL_LEN ( 10 ) /** 0xFF00FF00 **/         //: 01 ://
                           /** 1234567890 **/         //: -- ://
    #define LIT_LEN ( HEL_LEN +1 +1 +1 +1 )           //: 02 ://
    /** **************************************************** ***
        Amount of characters per u32 hex literal 
    
        [+1][+1][<-- +10 -->][+1][+1]
        ,         0xFF00FF00      \n 
    
    *** **************************************************** **/

        //:check_inputs:-------------------------------------://
        #define NAK_TEX BYREF_nak_tex  //:--------------: 01 ://
        #define NAK_LEN BYREF_nak_len  //:--------------: 02 ://

            /** @VID_IID[ 0121 ]TIME[ 08:39:42 ] **/
            /** Explaining Input Checks......... **/

            /** NIL: Nill as in nothing as in void ..........**/
            /** SAT: Sated as in full as in filled ..........**/
            /** N_Z: Non Zero as in positive or negative ....**/

            if(((U08* )0) ==  u08_arr ){ ERR("[NIL:u08_arr]");}

            if(((CHR**)0) ==  NAK_TEX ){ ERR("[NIL:NAK_TEX]");};
            if(((CHR* )0) !=(*NAK_TEX)){ ERR("[SAT:NAK_TEX]");};

            if(((I32* )0) ==  NAK_LEN ){ ERR("[NIL:NAK_LEN]");};
            if(        0  !=(*NAK_LEN)){ ERR("[N_Z:NAK_LEN]");};

        #undef  NAK_TEX  //:----------------------------: 01 ://
        #undef  NAK_LEN  //:----------------------------: 02 ://
        //:-------------------------------------:check_inputs://
        //:variable_declaration:-----------------------------://

            I32 nof_hel =( 0 ); /** NumberOf:HEx_Literals    **/
                                /** 32bit hex literals.      **/
                                                             
            I32 u08_dex =( 0 ); /** u08_arr[ u08_dex ]       **/
                                /** AKA: arr_dex             **/
                                                             
            I32 nak_dex =( 0 ); /** nak_tex[ nak_dex ]       **/
                                /** AKA: str_dex             **/

            I32 las_dex =( 0 ); /** Last index used when     **/
                                /** collecting next: hex_str **/

            CHR hex_str[ LIT_LEN ]={ 0 };

            /** @VID_IID[ 0121 ]TIME[ 07:58:23 ] *********** **/
            /** Don't want to mix BYREF double-pointer       **/
            /** crazy logic with our other logic, so use     **/
            /** these variables instead of                   **/
            /**      [ BYREF_nak_tex ]AND[ BYREF_nak_len ]   **/
            /** and then do:                                 **/
            /**     (*BYREF_nak_tex)==nak_tex                **/
            /**     (*BYREF_nak_len)==nak_len                **/
            /** when ready to return via output param.       **/
            /** ******************************************** **/
                                        /** **************** **/
                CHR* nak_tex=((CHR*)0); /** **************** **/
                I32  nak_len=(   0   ); /** **************** **/
                                        /** **************** **/
            /** ******************************************** **/

        //:-----------------------------:variable_declaration://
        //:variable_assignments:-----------------------------://

            /** Maybe? Nothing? Here? **/

        //:-----------------------------:variable_assignments://
        //:allocate_string_memory:---------------------------://

            /** arr_len : u08_arr's length **/

            nof_hel =( arr_len / 4 );
            if( (4*nof_hel) < arr_len ){
                   nof_hel++ ;
            };;

            /** ******************************************** **/
            /** @VID_IID[ 0121 ]TIME[ 07:50:50 ]             **/
            /** We are calloc(ing) a bit more memory than    **/
            /** needed per hex literal string. But better    **/
            /** a bit too much memory than not enough.       **/
            /** As long as we pad with null terminators,     **/
            /** we will be fine.                             **/
            /**                                              **/
            /** @VID_IID[ 0121 ]TIME[ 07:52:23 ]             **/
            /** Just in case we optimize[ nak_len ]          **/
            /** add( +1 ) to calloc to make 100% certain     **/
            /** we have room for a null terminator.          **/
            /** ******************************************** **/

            nak_len = ( nof_hel * LIT_LEN );
            nak_tex = calloc( nak_len + 1 , sizeof( CHR ) );
      
        //:---------------------------:allocate_string_memory://
        //:build_text_block_of_array_literals:---------------://
        #define FUN aac2020_phexdum_MAK_hex_str
        #define M_I ( arr_len - 1 )

            nak_dex =( 0  );
            las_dex =(0-10); /** last index of collect U32 **/
            for( u08_dex = 0 ; u08_dex <= M_I ; u08_dex ++ ){

                //: nak_dex++; /** FirstUsedValue == 0 **/
                
                /** @VID_IID[ 0121 ]TIME[ 06:45:50 ] ******* **/
                /** rbsrbs: alwways true but first time  *** **/
                /** rbsrbs: which is what you want, no?  *** **/
                /** rbsrbs: first line dont have comma   *** **/
                if(u08_dex) { 
                    nak_tex[ nak_dex ] = ','  ;
                             nak_dex++        ;
                };;
                /** **************************************** **/

                /** u08_dex === arr_dex **/

                FUN( 
                    u08_arr //:INN: array of bytes
                ,   u08_dex //:INN: first index to read

                , &(las_dex) //:OUTPARAM: last_used_index
                ,   hex_str  //:OUTPARAM: built_hex_literal
                );;

                /** __PRIME__ for-loop for next index **/
                u08_dex =( las_dex );

                
                /** **************************************** ***
                rbsrbs: you can use strcpy instead of second for
                rbsrbs: that's pure insanity PepeLaugh
                @VID_IID[ 0121 ]TIME[ 06:39:00 ]
                Copy all ten characters of[ hex_str ]
                into the naked index string.
                *** **************************************** **/
                nak_tex[ nak_dex +    0 ]=( hex_str[ 0 + 0 ] );
                nak_tex[ nak_dex +    1 ]=( hex_str[ 0 + 1 ] );
                nak_tex[ nak_dex +    2 ]=( hex_str[ 0 + 2 ] );
                nak_tex[ nak_dex +    3 ]=( hex_str[ 0 + 3 ] );
                nak_tex[ nak_dex +    4 ]=( hex_str[ 0 + 4 ] );
                nak_tex[ nak_dex +    5 ]=( hex_str[ 0 + 5 ] );
                nak_tex[ nak_dex +    6 ]=( hex_str[ 0 + 6 ] );
                nak_tex[ nak_dex +    7 ]=( hex_str[ 0 + 7 ] );
                nak_tex[ nak_dex +    8 ]=( hex_str[ 0 + 8 ] );
                nak_tex[ nak_dex +    9 ]=( hex_str[ 0 + 9 ] );
                         nak_dex +=( 10 );
                /** **************************************** **/

   
                if( u08_dex < M_I ){
                    nak_tex[ nak_dex ]='\n'; //: FILL____IT
                             nak_dex++     ; //: GET_OFF_IT
                };;

            };;

        #undef  FUN
        #undef  M_I
        //:---------------:build_text_block_of_array_literals://
        //:return_via_output_params:-------------------------://

            (*BYREF_nak_tex)=( nak_tex );
            (*BYREF_nak_len)=( nak_len );

        //:------------------------:return_via_output_params://


    #undef  HEL_LEN /** Hex  Literal Length **/       //: 01 ://
    #undef  LIT_LEN /** Literal Line Length **/       //: 02 ://
    }

#undef  U08  //:----------------------------------------: 01 ://
#undef  I32  //:----------------------------------------: 02 ://
#undef  CHR  //:----------------------------------------: 03 ://
#undef  ERR  //:----------------------------------------: 04 ://
//:=============================:PUBLIC_PROGRAM_API_FUNCTIONS://
//:PUBLIC_COMMAND_LINE_FUNCTIONS:============================://
#define I32 int32_t   /** GCC: <stdint.h> .....**/    //: 01 ://
#define U32 uint32_t  /** GCC: <stdint.h>      **/    //: 02 ://
#define U08 uint8_t   /** GCC: <stdint.h>      **/    //: 03 ://
#define N_S ((CHR*)0) /** NIL Character String **/    //: 04 ://
#define RET return                                    //: 05 ://
#define CMD PHEXDUM_CMDLINE_FUNCTION                  //: 06 ://
#define ERR aac2020_phexdum_Halt                      //: 07 ://
#define CHR          char                             //: 08 ://
#define U_C unsigned char                             //: 09 ://
#define C_C const    char                             //: 10 ://
#define CFS aac2020_phexdum_CreateFreeableString      //: 11 ://
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    extern C_C* AAC2020_PHEXDUM_CMD_pngfile_CTO_naktext( C_C* );
    extern C_C* AAC2020_PHEXDUM_CMD_naktext_CTO_pngfile( C_C* );

    extern C_C* AAC2020_PHEXDUM_CMD_pngfile_CTO_c99text( C_C* );
    extern C_C* AAC2020_PHEXDUM_CMD_c99text_CTO_pngfile( C_C* );

    extern C_C* AAC2020_PHEXDUM_CMD_NothingFound(        C_C* );

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    C_C*
    AAC2020_PHEXDUM_CMD_pngfile_CTO_naktext( 
    C_C*        rel_str_pngfile
    )
    {   if( N_S ==  rel_str_pngfile ){
            ERR(  "[rel_str_pngfile:___:NIL:003]");
        };;

        //:declare_variables:--------------------------------://

        /** LoadFileIfExists vars **/

            C_C* fip_inn =( rel_str_pngfile  );
            I32  bin_txt =( 0-1 /**NOT TEXT**/ );
            U08* fil_mem =((U08*)0);
            I32  fil_nob =(   0   );

        /** lodepng_decode32 vars **/

            U_C* out_chr_pix =((U_C*)0);
            U32  out_i32_wid =(   0   );
            U32  out_i32_hig =(   0   );
            U08* inn_u08_buf =((U08*)0);
            I32  inn_i32_siz =( 0 - 2 );

        /** AAC2020_PHEXDUM_U08Arr_CTO_NakTex ...... **/
        /** AAC2020_PHEXDUM_u08_arr_CTO_nak_tex vars **/

            U08* u08_arr = ((U08*)0);
            I32  arr_len = (   0   );

            CHR* nak_tex = ((CHR*)0);
            I32  nak_len = (   0   );

        //:--------------------------------:declare_variables://
        //:Load_File_From_Hard_Disk:-------------------------://

            /** Or solid state drive or whatever the .... **/

            AAC2020_PHEXDUM_LoadFileIfExists(
                fip_inn  //: CHR*  FIlePath_INNput
            ,   bin_txt  //: I32   is[ bin_txt ]?
            , &(fil_mem) //: U08** DESTINATION
            , &(fil_nob) //: I32*  file number of bytes
            );;

        //:-------------------------:Load_File_From_Hard_Disk://
        //:Get_Array_Of_Bytes_To_Stringify:------------------://
        #define STORE_PNG_FILE_BINARY_FROM_DISK ( 1 )
        #define  STORE_UNCOMPRESSED_BITMAP_DATA ( 2 )

            I32
            storage_mode=( STORE_PNG_FILE_BINARY_FROM_DISK );

            switch( storage_mode ){  //:- - - - - - - - - - -://

            case ( STORE_UNCOMPRESSED_BITMAP_DATA ):{

                lodepng_decode32(
                  &( out_chr_pix           )
                , &( out_i32_wid           )
                , &( out_i32_hig           )
                ,  ( inn_u08_buf = fil_mem )
                ,  ( inn_i32_siz = fil_nob )
                );;
        
                /**   @VID_IID[ 0121 ]TIME[ 08:08:15 ] **/
                /**   AKA: out_u08_pix == out_chr_pix  **/
                u08_arr =( out_chr_pix ); 
                arr_len =( out_i32_wid 
                         * out_i32_hig
                         * 4 );;
            };;break;
            case ( STORE_PNG_FILE_BINARY_FROM_DISK ):{

                u08_arr = fil_mem ;
                arr_len = fil_nob ;               

            };;break;
            default:{

                ERR("[BAD_STORAGE_CONSTANT_PROVIDED]");

            };;};; //:- - - - - - - - - - - - - - - - - - - -://

        #undef  STORE_PNG_FILE_BINARY_FROM_DISK  
        #undef   STORE_UNCOMPRESSED_BITMAP_DATA  
        //:------------------:Get_Array_Of_Bytes_To_Stringify://
        //:Stringify_U08_Array_As_U32_Hex_Dump:--------------://

            AAC2020_PHEXDUM_u08_arr_CTO_nak_tex(
                            u08_arr
            ,               arr_len
            ,             &(nak_tex)
            ,             &(nak_len)
            );;

        //:--------------:Stringify_U08_Array_As_U32_Hex_Dump://
        //:Save_File_To_Disk:--------------------------------://

            /** NOPE! Dont do this. That is the job of the   **/
            /** calling function. @VID_IID[0121]T[04:57:20 ] **/

        //:--------------------------------:Save_File_To_Disk://
                    
        /** EXPECT TEXT TO BE NULL TERMINATED **/
        assert( nak_tex[ nak_len + 0 ] == '\0' );
        RET(    nak_tex );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    C_C*
    AAC2020_PHEXDUM_CMD_naktext_CTO_pngfile( 
    C_C*        rel_str_naktext
    )
    {   if( N_S ==  rel_str_naktext ){
            ERR(  "[rel_str_naktext:___:NIL:004]");
        };;

        RET(CFS("[TODO:naktext_CTO_pngfile]\n\0" ));
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    C_C*
    AAC2020_PHEXDUM_CMD_pngfile_CTO_c99text( 
    C_C*        rel_str_pngfile           
    )
    {   if( N_S ==  rel_str_pngfile ){
            ERR(  "[rel_str_pngfile:___:NIL:001]");
        };;

        RET(CFS("[TODO:pngfile_CTO_c99text]\n\0" ));
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    C_C*
    AAC2020_PHEXDUM_CMD_c99text_CTO_pngfile( 
    C_C*        rel_str_c99text
    )
    {   if( N_S ==  rel_str_c99text ){
            ERR(  "[rel_str_c99text:___:NIL:002]");
        };;

        RET(CFS("[TODO:c99text_CTO_pngfile]\n\0"));
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    C_C* 
    AAC2020_PHEXDUM_CMD_NothingFound(
    C_C*                nothingfound
    ){
        if( nothingfound ){ /** NOOP **/ };
        RET(CFS( "[KANJICODER_SAYS:COMMAND_NOT_FOUND]\n\0" ));
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32  //:----------------------------------------: 01 ://
#undef  U32  //:----------------------------------------: 02 ://
#undef  U08  //:----------------------------------------: 03 ://
#undef  N_S  //:----------------------------------------: 04 ://
#undef  RET  //:----------------------------------------: 05 ://
#undef  CMD  //:----------------------------------------: 06 ://
#undef  ERR  //:----------------------------------------: 07 ://
#undef  CHR  //:----------------------------------------: 08 ://
#undef  U_C  //:----------------------------------------: 09 ://
#undef  C_C  //:----------------------------------------: 10 ://
#undef  CFS  //:----------------------------------------: 11 ://
//:============================:PUBLIC_COMMAND_LINE_FUNCTIONS://
//:COMMAND_LINE_HELPER_FUNCTIONS:============================://
#define I32  int32_t /** GCC: <stdint.h> **/          //: 01 ://
#define I_P intmax_t /** GCC: <stdint.h> **/          //: 02 ://
#define CHR const char                                //: 03 ://
#define ENU cmdenum                                   //: 04 ://
#define V_F PHEXDUM___ANY___FUNCTION                  //: 05 ://
#define CMD PHEXDUM_CMDLINE_FUNCTION                  //: 06 ://
#define ERR aac2020_phexdum_Halt                      //: 07 ://
#define LOG aac2020_phexdum_Info_any                  //: 08 ://

    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    V_F* /** returns integer or string **/
    aac2020_phexdum_PRIVATE_cmdname_CTO_cmdenum_ORR_cmdfunc(
               CHR* cmdname
    ,          CHR* cmdenum_ORR_cmdfunc
    )
    {
        LOG("[...cmdname_CTO_cmdenum_ORR_cmdfunc:BEG]",0);

        //:declare_variables:--------------------------------://

        I32   cmdenum =(      0   ); /** Command Enum     **/
        CMD*  cmdfunc =&(AAC2020_PHEXDUM_CMD_NothingFound ) ;

        CHR** syn_syn[ 5 ]={ 0 }; /** TAB:FUNCTION: Synonyms **/
        I32   tab_enu[ 5 ]={ 0 }; /** TAB:FUNCTION: Enums    **/
        CMD*  tab_fun[ 5 ]={ 0 }; /** TAB:FUNCTION: Funcs    **/
        
        CHR** tab_syn     =((CHR**)0);

        I32   syn =(    0    ); /** Command Synonym Index **/

        I32   chkenum ; /** CHECK:enumeration value **/

        //:--------------------------------:declare_variables://
        //:populate_tables:----------------------------------://

        syn_syn[ 0 ]=(aac2020_phexdum_SYN_invalid_command     );
        syn_syn[ 1 ]=(aac2020_phexdum_SYN_pngfile_CTO_c99text );
        syn_syn[ 2 ]=(aac2020_phexdum_SYN_c99text_CTO_pngfile );
        syn_syn[ 3 ]=(aac2020_phexdum_SYN_pngfile_CTO_naktext );
        syn_syn[ 4 ]=(aac2020_phexdum_SYN_naktext_CTO_pngfile );

        /** tab_enu == ....... **/
        tab_enu[ 0 ]=( 0 ); /** 0 == invalid enum **/
        tab_enu[ 1 ]=(aac2020_phexdum_ENU_pngfile_CTO_c99text );
        tab_enu[ 2 ]=(aac2020_phexdum_ENU_c99text_CTO_pngfile );
        tab_enu[ 3 ]=(aac2020_phexdum_ENU_pngfile_CTO_naktext );
        tab_enu[ 4 ]=(aac2020_phexdum_ENU_naktext_CTO_pngfile );

        /** tab_fun === cmdjump **/
        tab_fun[ 0 ]=(AAC2020_PHEXDUM_CMD_NothingFound        );
        tab_fun[ 1 ]=(AAC2020_PHEXDUM_CMD_pngfile_CTO_c99text );
        tab_fun[ 2 ]=(AAC2020_PHEXDUM_CMD_c99text_CTO_pngfile );
        tab_fun[ 3 ]=(AAC2020_PHEXDUM_CMD_pngfile_CTO_naktext );
        tab_fun[ 4 ]=(AAC2020_PHEXDUM_CMD_naktext_CTO_pngfile );

        if( 0 != tab_enu[ 0 ] ){ ERR("[ENU_MAP_ERR:000]"); };
        if( 1 != tab_enu[ 1 ] ){ ERR("[ENU_MAP_ERR:001]"); };
        if( 2 != tab_enu[ 2 ] ){ ERR("[ENU_MAP_ERR:002]"); };
        if( 3 != tab_enu[ 3 ] ){ ERR("[ENU_MAP_ERR:003]"); };
        if( 4 != tab_enu[ 4 ] ){ ERR("[ENU_MAP_ERR:004]"); };

        //:----------------------------------:populate_tables://
        //:find_the_command:---------------------------------://
        for( I32 cmd = 4 ; cmd >= 0 ; cmd -- ){

            /** ******************************************** **/
            /** @VID_IID[0120]TIME[ 01:17:02 ] ************* **/
            /** Too terse. Will be hard to understand in a   **/
            /** few months. So add lots of checking code to  **/
            /** verify understanding.                        **/
            /** ******************************************** **/

            tab_syn =( aac2020_phexdum_SYN_SYN[ cmd ] );

            if( tab_syn != syn_syn[ cmd ] ){
                ERR("[SYN_SYN_TABLE_MISMATCH]");
            };;

            /** ******************************************** **/

            //:are_we_on_the_command_we_want:----------------://
    
                /** loop through command synonyms **/
                for( syn = 0 ; syn <= (9-1) ; syn ++ ){

                    if(0 ==strcmp( cmdname , tab_syn[ syn ] )){

                        /** ******************************** **/
                        /** @VID_IID[ 0120 ]TIME[ 01:42:42 ] **/
                        /** Dont break here. We want to avoid**/
                        /** different code execution paths...**/
                        /** let loop run to the end..........**/
                        /** ******************************** **/

                        cmdenum =          cmd  ;
                        cmdfunc = tab_fun[ cmd ];
                        chkenum = tab_enu[ cmd ];

                        if( cmdenum != chkenum ){
                            ERR("[ENUMS_IMPROPERLY_MAPPED]");
                        };;
                    };;
                };;

            //:----------------:are_we_on_the_command_we_want://
        };;
        //:---------------------------------:find_the_command://

        V_F* return_data=((V_F*)0);
        if( 0 == strcmp( "cmdenum" , cmdenum_ORR_cmdfunc ) ){
            return_data=(  (V_F*)((I_P)cmdenum)  );
        }else
        if( 0 == strcmp( "cmdfunc" , cmdenum_ORR_cmdfunc ) ){
            return_data=(  (V_F*)cmdfunc );
        }else{
            ERR("[INVALID_RETURN_DATA_REQUESTED]");
        };;

        LOG("[...cmdname_CTO_cmdenum_ORR_cmdfunc:END]",0);
        return( return_data );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    I32
    AAC2020_PHEXDUM_cmdname_CTO_cmdenum(
    CHR*            cmdname
    )
    {
        I32 cmdenum=(I32)((I_P)(
        aac2020_phexdum_PRIVATE_cmdname_CTO_cmdenum_ORR_cmdfunc(
                                cmdname  , "cmdenum" )));;
        return( cmdenum );;
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
    CMD*
    AAC2020_PHEXDUM_cmdname_CTO_cmdfunc(
    CHR*            cmdname
    )
    {   /** #_WHY_CMD_CMD_CAST_#             **/
        /** @VID_IID[ 0120 ]TIME[ 04:56:23 ] **/

        CMD* cmdfunc=(CMD*)((CMD*)(
        aac2020_phexdum_PRIVATE_cmdname_CTO_cmdenum_ORR_cmdfunc(
                                cmdname  , "cmdfunc" )));;
        return( cmdfunc );
    }
    //: - - - - - - - - - - - - ---- - - - - - - - - - - - - ://
#undef  I32  //:----------------------------------------: 01 ://
#undef  I_P  //:----------------------------------------: 02 ://
#undef  CHR  //:----------------------------------------: 03 ://
#undef  ENU  //:----------------------------------------: 04 ://
#undef  V_F  //:----------------------------------------: 05 ://
#undef  CMD  //:----------------------------------------: 06 ://
#undef  ERR  //:----------------------------------------: 07 ://
#undef  LOG  //:----------------------------------------: 08 ://
//:============================:COMMAND_LINE_HELPER_FUNCTIONS://